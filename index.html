<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Voxel Demo â€” Minecraft-like (Single File)</title>
  <style>
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:#09121a;color:#e6f0f2}
    #ui{position:absolute;left:12px;top:12px;z-index:5}
    #instructions{background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;backdrop-filter:blur(6px);max-width:360px}
    #canvasWrap{width:100%;height:100%;overflow:hidden}
    button{cursor:pointer;border:0;padding:8px 12px;border-radius:8px;background:#58d68d;color:#03201a;font-weight:700}
    #hud{position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.35);padding:8px 12px;border-radius:8px;color:#9fb8a8}
    #toolbar{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;display:flex;gap:8px}
    .slot{padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.03)}
    a{color:#7fe3b8}
  </style>
</head>
<body>
  <div id="canvasWrap"></div>

  <div id="ui">
    <div id="instructions">
      <strong>3D Voxel Demo</strong>
      <p style="margin:6px 0 6px 0;color:#b7c9bf">Click to lock pointer. WASD to move, mouse to look. Left click: remove block. Right click (or Shift+left): place block. Keys 1-4 switch block types.</p>
      <p style="margin:6px 0 0 0;font-size:13px;color:#9fb8a8">Save this file as <code>index.html</code> and open locally or host on GitHub Pages.</p>
      <div style="margin-top:8px;display:flex;gap:8px"><button id="resetBtn">Reset World</button><button id="helpBtn">Controls</button></div>
    </div>
  </div>

  <div id="hud">Block: <span id="cur">Grass</span></div>
  <div id="toolbar">
    <div class="slot">1: Grass</div>
    <div class="slot">2: Dirt</div>
    <div class="slot">3: Stone</div>
    <div class="slot">4: Wood</div>
  </div>

<script>
// Single-file 3D voxel demo using three.js (from CDN). No build step required.
// Features: simple chunk, raycast to add/remove cubes, pointer lock first-person controls.

(async function(){
  // --- load three.js from CDN ---
  const THREE_URL = 'https://unpkg.com/three@0.158.0/build/three.min.js';
  const {THREE} = await new Promise((res,rej)=>{
    const s = document.createElement('script'); s.src = THREE_URL; s.onload = ()=>res(window.THREE); s.onerror = rej; document.head.appendChild(s);
  });

  // --- helper libs (PointerLockControls) ---
  // minimal implementation adapted inline to avoid extra loads
  class SimplePointerLockControls{
    constructor(camera, domElement){ this.camera = camera; this.domElement = domElement; this.velocity = new THREE.Vector3(); this.enabled=false; this.pitchObject = new THREE.Object3D(); this.yawObject = new THREE.Object3D(); this.yawObject.add(this.pitchObject); this.pitchObject.add(camera);
      this.PI_2 = Math.PI/2; this.pointerSpeed = 0.002;
      this.connect();
    }
    connect(){
      const onMouseMove = (e)=>{ if(!this.enabled) return; const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0; const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0; this.yawObject.rotation.y -= movementX * this.pointerSpeed; this.pitchObject.rotation.x -= movementY * this.pointerSpeed; this.pitchObject.rotation.x = Math.max( - this.PI_2, Math.min( this.PI_2, this.pitchObject.rotation.x ) ); };
      document.addEventListener('mousemove', onMouseMove);
      this.onPointerlockChange = ()=>{ this.enabled = document.pointerLockElement === this.domElement; };
      document.addEventListener('pointerlockchange', this.onPointerlockChange);
    }
    getObject(){ return this.yawObject; }
    dispose(){ document.removeEventListener('pointerlockchange', this.onPointerlockChange); }
  }

  // --- scene setup ---
  const wrap = document.getElementById('canvasWrap');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,10,20);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = false;
  wrap.appendChild(renderer.domElement);

  window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  // lights
  const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(5,10,7); scene.add(dir);
  const amb = new THREE.AmbientLight(0xffffff,0.35); scene.add(amb);

  // block materials (simple colored materials)
  const mats = {
    grass: new THREE.MeshLambertMaterial({color:0x66bb66}),
    dirt:  new THREE.MeshLambertMaterial({color:0x8b5a2b}),
    stone: new THREE.MeshLambertMaterial({color:0x9e9e9e}),
    wood:  new THREE.MeshLambertMaterial({color:0x8b6b4f})
  };
  const blockNames = ['grass','dirt','stone','wood'];
  let curBlock = 'grass';
  document.getElementById('cur').textContent = curBlock.charAt(0).toUpperCase()+curBlock.slice(1);

  // geometry cache
  const cubeGeo = new THREE.BoxGeometry(1,1,1);

  // world data: a small flat chunk
  const world = {}; // key: x + ',' + y + ',' + z -> mesh
  const group = new THREE.Group(); scene.add(group);

  function key(x,y,z){ return `${x},${y},${z}` }
  function addBlock(x,y,z,type){ if(world[key(x,y,z)]) return; const m = new THREE.Mesh(cubeGeo, mats[type]); m.position.set(x, y, z); group.add(m); world[key(x,y,z)] = {mesh:m, type}; }
  function removeBlock(x,y,z){ const k=key(x,y,z); if(!world[k]) return; group.remove(world[k].mesh); world[k].mesh.geometry.dispose(); // material reuse
    delete world[k]; }

  function generateFlat(width=24, depth=24, height=6){ const halfW = Math.floor(width/2); const halfD = Math.floor(depth/2);
    for(let x=-halfW;x<halfW;x++){
      for(let z=-halfD;z<halfD;z++){
        for(let y=0;y<height;y++){
          const t = y===height-1? 'grass' : (y>height-4? 'dirt':'stone'); addBlock(x,y,z,t);
        }
      }
    }
  }

  generateFlat(32,32,5);

  // floor helper (invisible plane for raycast when placing blocks beyond edge)
  const groundPlane = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), new THREE.MeshBasicMaterial({visible:false})); groundPlane.rotation.x = -Math.PI/2; groundPlane.position.y = -0.5; scene.add(groundPlane);

  // controls
  const controls = new SimplePointerLockControls(camera, renderer.domElement);
  const velocity = new THREE.Vector3(); const direction = new THREE.Vector3();
  const move = {forward:false,back:false,left:false,right:false};
  let canJump = true;

  document.addEventListener('keydown', (e)=>{
    if(e.code==='KeyW') move.forward=true;
    if(e.code==='KeyS') move.back=true;
    if(e.code==='KeyA') move.left=true;
    if(e.code==='KeyD') move.right=true;
    if(e.code==='Space' && canJump){ velocity.y += 6; canJump=false; }
    if(e.code==='Digit1') setBlockByIndex(0);
    if(e.code==='Digit2') setBlockByIndex(1);
    if(e.code==='Digit3') setBlockByIndex(2);
    if(e.code==='Digit4') setBlockByIndex(3);
  });
  document.addEventListener('keyup', (e)=>{
    if(e.code==='KeyW') move.forward=false;
    if(e.code==='KeyS') move.back=false;
    if(e.code==='KeyA') move.left=false;
    if(e.code==='KeyD') move.right=false;
  });

  function setBlockByIndex(i){ curBlock = blockNames[i]||curBlock; document.getElementById('cur').textContent = curBlock.charAt(0).toUpperCase()+curBlock.slice(1); }

  // pointer lock on click
  renderer.domElement.addEventListener('click', ()=>{ renderer.domElement.requestPointerLock(); });

  // raycaster for block selection
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  // highlight box
  const highlightMat = new THREE.MeshBasicMaterial({color:0xffffff,wireframe:true});
  const highlight = new THREE.Mesh(new THREE.BoxGeometry(1.02,1.02,1.02), highlightMat); highlight.visible=false; scene.add(highlight);

  // mouse handling for add/remove
  let isPointerLocked = false; document.addEventListener('pointerlockchange', ()=>{ isPointerLocked = document.pointerLockElement === renderer.domElement; });

  function getIntersect(){
    raycaster.setFromCamera(new THREE.Vector2(0,0), camera); // center ray
    const intersects = raycaster.intersectObjects(group.children.concat([groundPlane]), false);
    return intersects.length?intersects[0]:null;
  }

  function floorVec(v){ return {x:Math.floor(v.x+0.0001), y:Math.floor(v.y+0.0001), z:Math.floor(v.z+0.0001)} }

  window.addEventListener('mousedown', (e)=>{
    if(!isPointerLocked) return;
    const intersect = getIntersect(); if(!intersect) return;
    const pos = intersect.point; const normal = intersect.face.normal; const obj = intersect.object;
    if(e.button===0 && !e.shiftKey){ // left click remove
      // remove the block we hit
      if(obj===groundPlane) return; const p = floorVec(pos.sub(normal.multiplyScalar(0.01))); removeBlock(Math.round(p.x), Math.round(p.y), Math.round(p.z));
    } else { // right click or shift+left -> add block on adjacent
      // compute adjacent position
      const addPos = pos.add(intersect.face.normal); const p2 = floorVec(addPos); addBlock(Math.round(p2.x), Math.round(p2.y), Math.round(p2.z), curBlock);
    }
  });

  // simple physics movement
  const clock = new THREE.Clock();
  function animate(){
    const dt = Math.min(0.05, clock.getDelta());
    // movement
    direction.z = (move.forward?1:0) - (move.back?1:0);
    direction.x = (move.right?1:0) - (move.left?1:0);
    direction.normalize();
    const speed = 6.0;
    if(controls.enabled){
      velocity.x -= velocity.x * 10.0 * dt;
      velocity.z -= velocity.z * 10.0 * dt;
      velocity.y -= 9.8 * dt; // gravity
      if(direction.length()>0){ velocity.x += direction.x * speed * dt; velocity.z += direction.z * speed * dt; }

      controls.getObject().translateX(velocity.x);
      controls.getObject().translateY(velocity.y * dt);
      controls.getObject().translateZ(velocity.z);

      // ground collision (very simple)
      if(controls.getObject().position.y < 1.6){ velocity.y = 0; controls.getObject().position.y = 1.6; canJump=true; }
    }

    // highlight block under center
    const hit = getIntersect(); if(hit){ highlight.visible=true; const hpos = hit.point.clone(); if(hit.object!==groundPlane){ // highlight target block
        const p = hpos.sub(hit.face.normal.multiplyScalar(0.01)); const fv = floorVec(p); highlight.position.set(Math.round(fv.x), Math.round(fv.y), Math.round(fv.z));
      } else { // pointing at ground plane -> position to place
        const p2 = hpos.add(hit.face.normal); const fv2 = floorVec(p2); highlight.position.set(Math.round(fv2.x), Math.round(fv2.y), Math.round(fv2.z)); }
    } else { highlight.visible=false; }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // initial camera attachment
  controls.getObject().position.set(0,1.6,10); scene.add(controls.getObject());

  // UI buttons
  document.getElementById('resetBtn').addEventListener('click', ()=>{ // clear and regen
    for(const k in Object.assign({}, world)){ const [x,y,z]=k.split(',').map(Number); removeBlock(x,y,z); }
    generateFlat(32,32,5); controls.getObject().position.set(0,1.6,10); });

  document.getElementById('helpBtn').addEventListener('click', ()=>{ alert('Controls:\nWASD to move, mouse to look (click to lock).\nLeft click = remove block. Right click or Shift+Left = place block. Keys 1-4 to change block type.'); });

  // switch block with number keys visible change
  window.addEventListener('keydown', (e)=>{ if(e.code.startsWith('Digit')){ const n = parseInt(e.code.replace('Digit','')); if(n>=1 && n<=4) setBlockByIndex(n-1); } });

  // start animation
  animate();

})();
</script>
</body>
</html>
